; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare void @use(i1)
define void @loop_gep_phi(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_two_induction_vars(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_two_induction_vars(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I2_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i2.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void

}

define void @loop_gep_phi_two_induction_vars_2(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_two_induction_vars_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I2_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i2.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_inc_by_2(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_inc_by_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 2
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 2
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 2
  %inc = add nuw nsw i32 %i.0, 2
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_two_gep_phis(ptr %a, ptr %b, i32 %n) {
; CHECK-LABEL: @loop_two_gep_phis(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    [[ADD_PTR2:%.*]] = getelementptr inbounds i32, ptr [[B:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[B]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[PTR1_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR1_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[PTR1_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR1_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  %add.ptr2 = getelementptr inbounds i32, ptr %b, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %b, %entry ], [ %ptr.iv.next, %for.body ]
  %ptr1.iv = phi ptr [ %a, %entry ], [ %ptr1.iv.next, %for.body]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr1.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr1.iv, %a
  %c.3 = icmp ult ptr %ptr.iv, %add.ptr2
  %c.4 = icmp uge ptr %ptr.iv, %b
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  call void @use(i1 %c.3)
  call void @use(i1 %c.4)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %ptr1.iv.next = getelementptr inbounds i32, ptr %ptr1.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_induction_var_incorrect_step(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_induction_var_incorrect_step(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 4
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @start_val_non_zero(ptr %a, i32 %n) {
; CHECK-LABEL: @start_val_non_zero(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}


define void @loop_phi_ptr_not_inductive(ptr %a, ptr %base2, i32 %n) {
; CHECK-LABEL: @loop_phi_ptr_not_inductive(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[BASE2:%.*]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %base2, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_induction_switched(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_induction_switched(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY:%.*]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup


for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @induction_two_loops(ptr %a, ptr %b, i32 %n, i32 %n2) {
; CHECK-LABEL: @induction_two_loops(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    [[IDX_EXT1:%.*]] = zext i32 [[N2:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR2:%.*]] = getelementptr inbounds i32, ptr [[B:%.*]], i64 [[IDX_EXT1]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_PRED:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.pred:
; CHECK-NEXT:    br label [[FOR_COND2:%.*]]
; CHECK:       for.cond2:
; CHECK-NEXT:    [[I2_0:%.*]] = phi i32 [ 0, [[FOR_PRED]] ], [ [[INC21:%.*]], [[FOR_BODY2:%.*]] ]
; CHECK-NEXT:    [[PTR1_IV:%.*]] = phi ptr [ [[B]], [[FOR_PRED]] ], [ [[PTR1_IV_NEXT:%.*]], [[FOR_BODY2]] ]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[I2_0]], [[N2]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY2]], label [[FOR_COND_CLEANUP6:%.*]]
; CHECK:       for.body2:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR1_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR1_IV]], i64 1
; CHECK-NEXT:    [[INC21]] = add nuw nsw i32 [[I2_0]], 1
; CHECK-NEXT:    br label [[FOR_COND2]]
; CHECK:       for.cond.cleanup6:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  %idx.ext1 = zext i32 %n2 to i64
  %add.ptr2 = getelementptr inbounds i32, ptr %b, i64 %idx.ext1
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.pred

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.pred:
  br label %for.cond2

for.cond2:
  %i2.0 = phi i32 [ 0, %for.pred ], [ %inc21, %for.body2 ]
  %ptr1.iv = phi ptr [ %b, %for.pred ], [ %ptr1.iv.next, %for.body2 ]
  %cmp2 = icmp ult i32 %i2.0, %n2
  br i1 %cmp2, label %for.body2, label %for.cond.cleanup6

for.body2:
  %c.3 = icmp ult ptr %ptr1.iv, %add.ptr2
  %c.4 = icmp uge ptr %ptr1.iv, %b
  call void @use(i1 %c.3)
  call void @use(i1 %c.4)
  %ptr1.iv.next = getelementptr inbounds i32, ptr %ptr1.iv, i64 1
  %inc21 = add nuw nsw i32 %i2.0, 1
  br label %for.cond2

for.cond.cleanup6:
  ret void
}

define void @loop_gep_phi_incoming_value_switched(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_incoming_value_switched(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[A]], [[ENTRY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %ptr.iv.next, %for.body ], [ %a, %entry ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_different_types_cmp(i8* %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_different_types_cmp(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i128, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, i8* %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi i8* [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult i8* %ptr.iv, %add.ptr
  %c.2 = icmp uge i8* %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i128, i8* %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_different_types_cmp2(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_different_types_cmp2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i8, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup


for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i8, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @phi_ptr_multi_latch(ptr %a, i32 %n) {
; CHECK-LABEL: @phi_ptr_multi_latch(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ], [ [[INC2:%.*]], [[LATCH:%.*]] ]
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[FOR_BODY]] ], [ [[ADD_2:%.*]], [[LATCH]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[PTR_IV_NEXT2:%.*]], [[LATCH]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[LATCH]]
; CHECK:       latch:
; CHECK-NEXT:    [[PTR_IV_NEXT2]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 -1
; CHECK-NEXT:    [[LOAD_2:%.*]] = load i32, ptr [[PTR_IV]], align 4
; CHECK-NEXT:    [[ADD_2]] = add nsw i32 [[R_0]], [[LOAD_2]]
; CHECK-NEXT:    [[INC2]] = add nuw nsw i32 [[I_0]], -1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[R_0]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_COND]], label [[END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[PTR_IV]], align 4
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[R_0]], [[TMP0]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ], [%inc2, %latch]
  %r.0 = phi i32 [ 0, %entry ], [ %add, %for.body ], [%add.2, %latch]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ], [%ptr.iv.next2, %latch]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %latch

latch:
  %ptr.iv.next2 = getelementptr inbounds i32, ptr %ptr.iv, i64 -1
  %load.2 = load i32, ptr %ptr.iv, align 4
  %add.2 = add nsw i32 %r.0, %load.2
  %inc2 = add nuw nsw i32 %i.0, -1
  %cmp2 = icmp ule i32 %r.0, 10
  br i1 %cmp2, label %for.cond, label %end

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %0 = load i32, ptr %ptr.iv, align 4
  %add = add nsw i32 %r.0, %0
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

end:
ret void
}

define void @loop_gep_phi_vector(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_vector(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds <2 x i8>, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi i8* [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds <2 x i8>, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_vector_2(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_vector_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds <4 x i32>, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi i8* [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds <4 x i32>, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_vector_scalable(ptr %a, i32 %n) {
; CHECK-LABEL: @loop_gep_phi_vector_scalable(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds <vscale x 2 x i8>, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi i8* [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds <vscale x 2 x i8>, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_non_const_int_iv_increment(ptr %a, i32 %n, i32 %increment) {
; CHECK-LABEL: @loop_gep_phi_non_const_int_iv_increment(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], [[INCREMENT:%.*]]
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = add nuw nsw i32 %i.0, %increment
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_non_const_ptr_iv_increment(ptr %a, i32 %n, i32 %increment) {
; CHECK-LABEL: @loop_gep_phi_non_const_ptr_iv_increment(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]]
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i32 [[INCREMENT:%.*]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr
  %c.2 = icmp uge ptr %ptr.iv, %a
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i32 %increment
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define i1 @loop_gep_phi_non_const_induction_ptr(i64 %arg, ptr %arg1) {
; CHECK-LABEL: @loop_gep_phi_non_const_induction_ptr(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB:%.*]] ], [ [[ADD:%.*]], [[BB2]] ]
; CHECK-NEXT:    [[PHI3:%.*]] = phi ptr [ [[ARG1:%.*]], [[BB]] ], [ [[GETELEMENTPTR:%.*]], [[BB2]] ]
; CHECK-NEXT:    [[GETELEMENTPTR]] = getelementptr i8, ptr [[PHI3]], i64 [[ARG:%.*]]
; CHECK-NEXT:    [[ADD]] = add i32 [[PHI]], 1
; CHECK-NEXT:    br label [[BB2]]
;
bb:
  br label %bb2
bb2:                                              ; preds = %bb2, %bb
  %phi = phi i32 [ 0, %bb ], [ %add, %bb2 ]
  %phi3 = phi ptr [ %arg1, %bb ], [ %getelementptr, %bb2 ]
  %getelementptr = getelementptr i8, ptr %phi3, i64 %arg
  %add = add i32 %phi, 1
  br label %bb2
}
