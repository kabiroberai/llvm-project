; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

; Tests for using inbounds information from GEPs.

declare void @noundef(ptr noundef)

%struct.1 = type { i32, i64, i8 }

define i1 @struct_gep_dimensions_known_inbounds(ptr %start, ptr %high, i32 %idx) {
; CHECK-LABEL: @struct_gep_dimensions_known_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_1:%.*]], ptr [[START:%.*]], i64 6, i32 0
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[ADD_PTR]], [[HIGH:%.*]]
; CHECK-NEXT:    br i1 [[C_1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[START_0:%.*]] = getelementptr [[STRUCT_1]], ptr [[START]], i64 5, i32 0
; CHECK-NEXT:    ret i1 true
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %add.ptr = getelementptr inbounds %struct.1, ptr %start, i64 6, i32 0
  %c.1 = icmp ule ptr %add.ptr, %high
  br i1 %c.1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %start.0 = getelementptr %struct.1, ptr %start, i64 5, i32 0
  %c.0 = icmp ult ptr %start.0, %high
  ret i1 %c.0

if.end:                                           ; preds = %entry
  ret i1 1
}

%struct.array = type { [4 x i8] }

define i8 @struct_gep_dimensions_known_inbounds2(ptr %a) {
; CHECK-LABEL: @struct_gep_dimensions_known_inbounds2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_ARRAY:%.*]], ptr [[A:%.*]], i64 0, i32 0, i64 0
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT_ARRAY]], ptr [[A]], i64 0, i32 0, i64 4
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_ARRAY]], ptr [[A]], i64 0, i32 0, i64 1
; CHECK-NEXT:    [[OR_COND35:%.*]] = and i1 true, true
; CHECK-NEXT:    br i1 [[OR_COND35]], label [[EXIT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    ret i8 0
; CHECK:       exit:
; CHECK-NEXT:    [[L:%.*]] = load i8, ptr [[ARRAYDECAY]], align 1
; CHECK-NEXT:    ret i8 [[L]]
;
entry:
  %arraydecay = getelementptr inbounds %struct.array, ptr %a, i64 0, i32 0, i64 0
  %upper = getelementptr inbounds %struct.array, ptr %a, i64 0, i32 0, i64 4
  %0 = getelementptr %struct.array, ptr %a, i64 0, i32 0, i64 1
  %1 = icmp ult ptr %0, %upper
  %2 = icmp uge ptr %0, %arraydecay
  %or.cond35 = and i1 %1, %2
  br i1 %or.cond35, label %exit, label %trap

trap:
  ret i8 0

exit:
  %l = load i8, ptr %arraydecay, align 1
  ret i8 %l
}
%struct.array2 = type { [4 x i8], [4 x i8]}
define i8 @struct_gep_dimensions_known_inbounds3(ptr %a) {
; CHECK-LABEL: @struct_gep_dimensions_known_inbounds3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2:%.*]], ptr [[A:%.*]], i64 0, i32 0, i64 0
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2]], ptr [[A]], i64 0, i32 1, i64 4
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_ARRAY2]], ptr [[A]], i64 0, i32 1, i64 3
; CHECK-NEXT:    [[OR_COND35:%.*]] = and i1 true, true
; CHECK-NEXT:    br i1 [[OR_COND35]], label [[EXIT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    ret i8 0
; CHECK:       exit:
; CHECK-NEXT:    [[L:%.*]] = load i8, ptr [[ARRAYDECAY]], align 1
; CHECK-NEXT:    ret i8 [[L]]
;
entry:
  %arraydecay = getelementptr inbounds %struct.array2, ptr %a, i64 0, i32 0, i64 0
  %upper = getelementptr inbounds %struct.array2, ptr %a, i64 0, i32 1, i64 4
  %0 = getelementptr %struct.array2, ptr %a, i64 0, i32 1, i64 3
  %1 = icmp ult ptr %0, %upper
  %2 = icmp uge ptr %0, %arraydecay
  %or.cond35 = and i1 %1, %2
  br i1 %or.cond35, label %exit, label %trap

trap:
  ret i8 0

exit:
  %l = load i8, ptr %arraydecay, align 1
  ret i8 %l
}

; this should trap given that the struct index for %0 > %upper
define i8 @struct_gep_dimensions_known_inbounds4(ptr %a) {
; CHECK-LABEL: @struct_gep_dimensions_known_inbounds4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2:%.*]], ptr [[A:%.*]], i64 0, i32 0, i64 0
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2]], ptr [[A]], i64 0, i32 0, i64 4
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_ARRAY2]], ptr [[A]], i64 0, i32 1, i64 3
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult ptr [[TMP0]], [[UPPER]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp uge ptr [[TMP0]], [[ARRAYDECAY]]
; CHECK-NEXT:    [[OR_COND35:%.*]] = and i1 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[OR_COND35]], label [[EXIT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    ret i8 0
; CHECK:       exit:
; CHECK-NEXT:    [[L:%.*]] = load i8, ptr [[ARRAYDECAY]], align 1
; CHECK-NEXT:    ret i8 [[L]]
;
entry:
  %arraydecay = getelementptr inbounds %struct.array2, ptr %a, i64 0, i32 0, i64 0
  %upper = getelementptr inbounds %struct.array2, ptr %a, i64 0, i32 0, i64 4
  %0 = getelementptr %struct.array2, ptr %a, i64 0, i32 1, i64 3
  %1 = icmp ult ptr %0, %upper
  %2 = icmp uge ptr %0, %arraydecay
  %or.cond35 = and i1 %1, %2
  br i1 %or.cond35, label %exit, label %trap

trap:
  ret i8 0

exit:
  %l = load i8, ptr %arraydecay, align 1
  ret i8 %l
}

define i8 @struct_gep_multi_dimensions_with_var_const_idx(ptr %a, i64 %idx) {
; CHECK-LABEL: @struct_gep_multi_dimensions_with_var_const_idx(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2:%.*]], ptr [[A:%.*]], i64 0, i32 0, i64 0
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT_ARRAY2]], ptr [[A]], i64 [[IDX:%.*]], i32 0, i64 4
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_ARRAY2]], ptr [[A]], i64 [[IDX]], i32 0, i64 3
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult ptr [[TMP0]], [[UPPER]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp uge ptr [[TMP0]], [[ARRAYDECAY]]
; CHECK-NEXT:    [[OR_COND35:%.*]] = and i1 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[OR_COND35]], label [[EXIT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    ret i8 0
; CHECK:       exit:
; CHECK-NEXT:    [[L:%.*]] = load i8, ptr [[ARRAYDECAY]], align 1
; CHECK-NEXT:    ret i8 [[L]]
;
entry:
  %arraydecay = getelementptr inbounds %struct.array2, ptr %a, i64 0, i32 0, i64 0
  %upper = getelementptr inbounds %struct.array2, ptr %a, i64 %idx, i32 0, i64 4
  %0 = getelementptr %struct.array2, ptr %a, i64 %idx, i32 0, i64 3
  %1 = icmp ult ptr %0, %upper
  %2 = icmp uge ptr %0, %arraydecay
  %or.cond35 = and i1 %1, %2
  br i1 %or.cond35, label %exit, label %trap

trap:
  ret i8 0

exit:
  %l = load i8, ptr %arraydecay, align 1
  ret i8 %l
}

define i1 @struct_gep_first_dimension_may_not_be_inbounds(ptr %start, ptr %high, i32 %idx) {
; CHECK-LABEL: @struct_gep_first_dimension_may_not_be_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_1:%.*]], ptr [[START:%.*]], i64 6, i32 0
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[ADD_PTR]], [[HIGH:%.*]]
; CHECK-NEXT:    br i1 [[C_1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[START_0:%.*]] = getelementptr [[STRUCT_1]], ptr [[START]], i64 7, i32 0
; CHECK-NEXT:    [[C_0:%.*]] = icmp ult ptr [[START_0]], [[HIGH]]
; CHECK-NEXT:    ret i1 [[C_0]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %add.ptr = getelementptr inbounds %struct.1, ptr %start, i64 6, i32 0
  %c.1 = icmp ule ptr %add.ptr, %high
  br i1 %c.1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %start.0 = getelementptr %struct.1, ptr %start, i64 7, i32 0
  %c.0 = icmp ult ptr%start.0, %high
  ret i1 %c.0

if.end:                                           ; preds = %entry
  ret i1 1
}

%struct.2 = type { i32, [20 x i64], i8 }

; TODO: Should keep and use multiple upper bounds.
define i1 @all_dimension_known_inbounds(ptr %start, ptr %high, i32 %idx) {
; CHECK-LABEL: @all_dimension_known_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT_PLUS_1:%.*]] = add nuw nsw i32 [[IDX:%.*]], 1
; CHECK-NEXT:    [[IDX_EXT_PLUS_1_EXT:%.*]] = zext i32 [[IDX_EXT_PLUS_1]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_2:%.*]], ptr [[START:%.*]], i64 6, i32 1, i64 5
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[ADD_PTR]], [[HIGH:%.*]]
; CHECK-NEXT:    br i1 [[C_1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[START_0:%.*]] = getelementptr [[STRUCT_2]], ptr [[START]], i64 5, i32 1, i64 5
; CHECK-NEXT:    ret i1 true
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %idx.ext.plus.1 = add nuw nsw i32 %idx, 1
  %idx.ext.plus.1.ext = zext i32 %idx.ext.plus.1 to i64
  %add.ptr = getelementptr inbounds %struct.2, ptr %start, i64 6, i32 1, i64 5
  %c.1 = icmp ule ptr %add.ptr, %high
  br i1 %c.1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idx.ext = zext i32 %idx to i64
  %start.0 = getelementptr %struct.2, ptr %start, i64 5, i32 1, i64 5
  %c.0 = icmp ult ptr %start.0, %high
  ret i1 %c.0

if.end:                                           ; preds = %entry
  ret i1 1
}

define i1 @first_dimension_may_not_be_inbounds_2(ptr %start, ptr %high, i32 %idx) {
; CHECK-LABEL: @first_dimension_may_not_be_inbounds_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT_PLUS_1:%.*]] = add nuw nsw i32 [[IDX:%.*]], 1
; CHECK-NEXT:    [[IDX_EXT_PLUS_1_EXT:%.*]] = zext i32 [[IDX_EXT_PLUS_1]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_2:%.*]], ptr [[START:%.*]], i64 6, i32 1, i64 5
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[ADD_PTR]], [[HIGH:%.*]]
; CHECK-NEXT:    br i1 [[C_1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[START_0:%.*]] = getelementptr [[STRUCT_2]], ptr [[START]], i64 7, i32 1, i64 3
; CHECK-NEXT:    [[C_0:%.*]] = icmp ult ptr [[START_0]], [[HIGH]]
; CHECK-NEXT:    ret i1 [[C_0]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %idx.ext.plus.1 = add nuw nsw i32 %idx, 1
  %idx.ext.plus.1.ext = zext i32 %idx.ext.plus.1 to i64
  %add.ptr = getelementptr inbounds %struct.2, ptr %start, i64 6, i32 1, i64 5
  %c.1 = icmp ule ptr %add.ptr, %high
  br i1 %c.1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idx.ext = zext i32 %idx to i64
  %start.0 = getelementptr %struct.2, ptr %start, i64 7, i32 1, i64 3
  %c.0 = icmp ult ptr %start.0, %high
  ret i1 %c.0

if.end:                                           ; preds = %entry
  ret i1 1
}

define i1 @third_dimension_may_not_be_inbounds(ptr %start, ptr %high, i32 %idx) {
; CHECK-LABEL: @third_dimension_may_not_be_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT_PLUS_1:%.*]] = add nuw nsw i32 [[IDX:%.*]], 1
; CHECK-NEXT:    [[IDX_EXT_PLUS_1_EXT:%.*]] = zext i32 [[IDX_EXT_PLUS_1]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_2:%.*]], ptr [[START:%.*]], i64 6, i32 1, i64 5
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[ADD_PTR]], [[HIGH:%.*]]
; CHECK-NEXT:    br i1 [[C_1]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[START_0:%.*]] = getelementptr [[STRUCT_2]], ptr [[START]], i64 5, i32 1, i64 6
; CHECK-NEXT:    ret i1 true
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %idx.ext.plus.1 = add nuw nsw i32 %idx, 1
  %idx.ext.plus.1.ext = zext i32 %idx.ext.plus.1 to i64
  %add.ptr = getelementptr inbounds %struct.2, ptr %start, i64 6, i32 1, i64 5
  %c.1 = icmp ule ptr %add.ptr, %high
  br i1 %c.1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idx.ext = zext i32 %idx to i64
  %start.0 = getelementptr %struct.2, ptr %start, i64 5, i32 1, i64 6
  %c.0 = icmp ult ptr %start.0, %high
  ret i1 %c.0

if.end:                                           ; preds = %entry
  ret i1 1
}

%struct = type { i64, i64, i16 }

; Test case where the inbounds GEP only indexes the first dimension. %gep uses
; the same first index, but accesses the third struct field. Computing %gep may
; overflow, due to adding the field offset and should not be de-composed.
define i1 @inbounds_first_struct_idx_compared_to_gep_with_const_second_idx(i8 %len, ptr %ptr) {
; CHECK-LABEL: @inbounds_first_struct_idx_compared_to_gep_with_const_second_idx(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i8 [[LEN:%.*]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT:%.*]], ptr [[PTR:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i64 [[LEN_EXT]], i32 2
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult ptr [[GEP]], [[UPPER]]
; CHECK-NEXT:    br i1 [[CMP]], label [[EXIT_0:%.*]], label [[EXIT_1:%.*]]
; CHECK:       exit.0:
; CHECK-NEXT:    ret i1 true
; CHECK:       exit.1:
; CHECK-NEXT:    ret i1 false
;
entry:
  %len.ext = zext i8 %len to i64
  %upper = getelementptr inbounds %struct, ptr %ptr, i64 %len.ext
  %gep = getelementptr %struct, ptr %ptr, i64 %len.ext, i32 2
  %cmp = icmp ult ptr %gep, %upper
  br i1 %cmp, label %exit.0, label %exit.1

exit.0:
  ret i1 %cmp

exit.1:
  ret i1 0
}

; Similar to @inbounds_first_struct_idx_compared_to_gep_with_const_second_idx,
; but with a SGE check to ensure the upper bound offset is non-negative.
define i1 @inbounds_first_struct_idx_compared_to_gep_with_const_second_idx_2(i8 %len, ptr %ptr) {
; CHECK-LABEL: @inbounds_first_struct_idx_compared_to_gep_with_const_second_idx_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COUNT_POSITIVE_I:%.*]] = icmp sge i8 [[LEN:%.*]], 0
; CHECK-NEXT:    br i1 [[COUNT_POSITIVE_I]], label [[THEN:%.*]], label [[EXIT_1:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i8 [[LEN]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT:%.*]], ptr [[PTR:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i64 [[LEN_EXT]], i32 2
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult ptr [[GEP]], [[UPPER]]
; CHECK-NEXT:    br i1 [[CMP]], label [[EXIT_0:%.*]], label [[EXIT_1]]
; CHECK:       exit.0:
; CHECK-NEXT:    ret i1 true
; CHECK:       exit.1:
; CHECK-NEXT:    ret i1 false
;
entry:
  %count.positive.i = icmp sge i8 %len, 0
  br i1 %count.positive.i, label %then, label %exit.1

then:
  %len.ext = zext i8 %len to i64
  %upper = getelementptr inbounds %struct, ptr %ptr, i64 %len.ext
  %gep = getelementptr %struct, ptr %ptr, i64 %len.ext, i32 2
  %cmp = icmp ult ptr %gep, %upper
  br i1 %cmp, label %exit.0, label %exit.1

exit.0:
  ret i1 %cmp

exit.1:
  ret i1 0
}

; The inbounds GEP %upper accesses the same field as %gep, hence %gep can not overflow.
define i1 @inbounds_last_struct_field_compared_to_gep_with_const_second_idx(i8 %len, ptr %ptr) {
; CHECK-LABEL: @inbounds_last_struct_field_compared_to_gep_with_const_second_idx(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i8 [[LEN:%.*]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT:%.*]], ptr [[PTR:%.*]], i64 [[LEN_EXT]], i32 2
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i64 [[LEN_EXT]], i32 2
; CHECK-NEXT:    br i1 false, label [[EXIT_0:%.*]], label [[EXIT_1:%.*]]
; CHECK:       exit.0:
; CHECK-NEXT:    ret i1 false
; CHECK:       exit.1:
; CHECK-NEXT:    ret i1 false
;
entry:
  %len.ext = zext i8 %len to i64
  %upper = getelementptr inbounds %struct, ptr %ptr, i64 %len.ext, i32 2
  %gep = getelementptr %struct, ptr %ptr, i64 %len.ext, i32 2
  %cmp = icmp ult i16* %gep, %upper
  br i1 %cmp, label %exit.0, label %exit.1

exit.0:
  ret i1 %cmp

exit.1:
  ret i1 0
}

; The inbounds GEP %upper accesses the field after %gep, hence %gep can not overflow.
define i1 @inbounds_last_struct_field_compared_to_gep_with_const_second_idx_2(i8 %len, ptr %ptr) {
; CHECK-LABEL: @inbounds_last_struct_field_compared_to_gep_with_const_second_idx_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i8 [[LEN:%.*]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT:%.*]], ptr [[PTR:%.*]], i64 [[LEN_EXT]], i32 2
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i64 [[LEN_EXT]], i32 1
; CHECK-NEXT:    br i1 true, label [[EXIT_0:%.*]], label [[EXIT_1:%.*]]
; CHECK:       exit.0:
; CHECK-NEXT:    ret i1 true
; CHECK:       exit.1:
; CHECK-NEXT:    ret i1 false
;
entry:
  %len.ext = zext i8 %len to i64
  %upper = getelementptr inbounds %struct, ptr %ptr, i64 %len.ext, i32 2
  %gep = getelementptr %struct, ptr %ptr, i64 %len.ext, i32 1
  %cmp = icmp ult ptr %gep, %upper
  br i1 %cmp, label %exit.0, label %exit.1

exit.0:
  ret i1 %cmp

exit.1:
  ret i1 0
}

; %idx is not related to %len, so we cannot determine inbounds for %gep.1 or %gep.2.
; %cmp cannot be simplified.
define i1 @geps_struct_var_indices_not_related_to_upper_bound_not_guaranteed_inbounds(i8 %len, i8 %idx, ptr %ptr) {
; CHECK-LABEL: @geps_struct_var_indices_not_related_to_upper_bound_not_guaranteed_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i8 [[LEN:%.*]] to i16
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i8 [[IDX:%.*]] to i16
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT:%.*]], ptr [[PTR:%.*]], i16 [[LEN_EXT]], i32 2
; CHECK-NEXT:    call void @noundef(ptr noundef [[UPPER]])
; CHECK-NEXT:    [[ADD:%.*]] = add nuw nsw i16 [[IDX_EXT]], 1
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i16 [[IDX_EXT]], i32 1
; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr [[STRUCT]], ptr [[PTR]], i16 [[ADD]], i32 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult ptr [[GEP_1]], [[GEP_2]]
; CHECK-NEXT:    br i1 [[CMP]], label [[EXIT_0:%.*]], label [[EXIT_1:%.*]]
; CHECK:       exit.0:
; CHECK-NEXT:    ret i1 true
; CHECK:       exit.1:
; CHECK-NEXT:    ret i1 false
;
entry:
  %len.ext = zext i8 %len to i16
  %idx.ext = zext i8 %idx to i16
  %upper = getelementptr inbounds %struct, ptr %ptr, i16 %len.ext, i32 2
  call void @noundef(ptr noundef %upper)
  %add = add nuw nsw i16 %idx.ext, 1
  %gep.1 = getelementptr %struct, ptr %ptr, i16 %idx.ext, i32 1
  %gep.2 = getelementptr %struct, ptr %ptr, i16 %add, i32 1
  %cmp = icmp ult ptr %gep.1, %gep.2
  br i1 %cmp, label %exit.0, label %exit.1

exit.0:
  ret i1 %cmp

exit.1:
  ret i1 false
}

%struct.buf_var_size = type { i32, [0 x i32] }

define noundef i1 @test_var_size_buffer_gep_inbounds_1(ptr noundef %bp, i32 %idx, i32 %len) {
; CHECK-LABEL: @test_var_size_buffer_gep_inbounds_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[ARR:%.*]] = getelementptr inbounds [[STRUCT_BUF_VAR_SIZE:%.*]], ptr [[BP:%.*]], i64 0, i32 1
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARR]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[IDX_EXT]]
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %idx, %len
  br i1 %cmp, label %then, label %else

then:
  %arr = getelementptr inbounds %struct.buf_var_size, ptr %bp, i64 0, i32 1
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %arr, i64 %len.ext
  %idx.ext = zext i32 %idx to i64
  %gep = getelementptr i32, ptr %arr, i64 %idx.ext
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_var_size_buffer_gep_inbounds_2(ptr noundef %bp, i32 %idx, i32 %len) {
; CHECK-LABEL: @test_var_size_buffer_gep_inbounds_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[ARR:%.*]] = getelementptr inbounds [[STRUCT_BUF_VAR_SIZE:%.*]], ptr [[BP:%.*]], i64 0, i32 1
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARR]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[ARR_2:%.*]] = getelementptr [[STRUCT_BUF_VAR_SIZE]], ptr [[BP]], i64 0, i32 1
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[ARR_2]], i64 [[IDX_EXT]]
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %idx, %len
  br i1 %cmp, label %then, label %else

then:
  %arr = getelementptr inbounds %struct.buf_var_size, ptr %bp, i64 0, i32 1
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %arr, i64 %len.ext
  %idx.ext = zext i32 %idx to i64
  %arr.2 = getelementptr %struct.buf_var_size, ptr %bp, i64 0, i32 1
  %gep = getelementptr i32, ptr %arr.2, i64 %idx.ext
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_var_size_buffer_gep_missing_inbounds(ptr noundef %bp, i32 %idx, i32 %len) {
; CHECK-LABEL: @test_var_size_buffer_gep_missing_inbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[ARR:%.*]] = getelementptr [[STRUCT_BUF_VAR_SIZE:%.*]], ptr [[BP:%.*]], i64 0, i32 1
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[IDX_EXT]]
; CHECK-NEXT:    [[C:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[C]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %idx, %len
  br i1 %cmp, label %then, label %else

then:
  %arr = getelementptr %struct.buf_var_size, ptr %bp, i64 0, i32 1
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr i32, ptr %arr, i64 %len.ext
  %idx.ext = zext i32 %idx to i64
  %gep = getelementptr i32, ptr %arr, i64 %idx.ext
  %c = icmp ult ptr %gep, %add.ptr
  ret i1 %c

else:
  ret i1 0
}

%struct.T = type { i32, [10 x [20 x i8]] }

define noundef i1 @test_2_var_size_gep_inbounds_1(ptr noundef %base, i32 %idx.1, i32 %idx.2, i32 %len) {
; CHECK-LABEL: @test_2_var_size_gep_inbounds_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_1_ULT:%.*]] = icmp ult i32 [[IDX_1:%.*]], 2
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_ULT]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX_2:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_T:%.*]], ptr [[BASE:%.*]], i64 0, i32 1, i64 2, i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_1_EXT:%.*]] = zext i32 [[IDX_1]] to i64
; CHECK-NEXT:    [[IDX_2_EXT:%.*]] = zext i32 [[IDX_2]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT_T]], ptr [[BASE]], i64 0, i32 1, i64 [[IDX_1_EXT]], i64 [[IDX_2_EXT]]
; CHECK-NEXT:    [[T:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[T]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %idx.1.ult = icmp ult i32 %idx.1, 2
  call void @llvm.assume(i1 %idx.1.ult)
  %cmp = icmp ult i32 %idx.2, %len
  br i1 %cmp, label %then, label %else

then:
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr inbounds %struct.T, ptr %base, i64 0, i32 1, i64 2, i64 %len.ext
  %idx.1.ext = zext i32 %idx.1 to i64
  %idx.2.ext = zext i32 %idx.2 to i64
  %gep = getelementptr %struct.T, ptr %base, i64 0, i32 1, i64 %idx.1.ext, i64 %idx.2.ext
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_2_var_size_idx1_may_be_out_of_bounds(ptr noundef %base, i32 %idx.1, i32 %idx.2, i32 %len) {
; CHECK-LABEL: @test_2_var_size_idx1_may_be_out_of_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX_2:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_T:%.*]], ptr [[BASE:%.*]], i64 0, i32 1, i64 2, i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_1_EXT:%.*]] = zext i32 [[IDX_1:%.*]] to i64
; CHECK-NEXT:    [[IDX_2_EXT:%.*]] = zext i32 [[IDX_2]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT_T]], ptr [[BASE]], i64 0, i32 1, i64 [[IDX_1_EXT]], i64 [[IDX_2_EXT]]
; CHECK-NEXT:    [[T:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[T]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %idx.2, %len
  br i1 %cmp, label %then, label %else

then:
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr inbounds %struct.T, ptr %base, i64 0, i32 1, i64 2, i64 %len.ext
  %idx.1.ext = zext i32 %idx.1 to i64
  %idx.2.ext = zext i32 %idx.2 to i64
  %gep = getelementptr %struct.T, ptr %base, i64 0, i32 1, i64 %idx.1.ext, i64 %idx.2.ext
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_2_var_size_idx2_may_be_out_of_bounds(ptr noundef %base, i32 %idx.1, i32 %idx.2, i32 %len) {
; CHECK-LABEL: @test_2_var_size_idx2_may_be_out_of_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX_1:%.*]], 2
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = zext i32 [[LEN:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_T:%.*]], ptr [[BASE:%.*]], i64 0, i32 1, i64 2, i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_1_EXT:%.*]] = zext i32 [[IDX_1]] to i64
; CHECK-NEXT:    [[IDX_2_EXT:%.*]] = zext i32 [[IDX_2:%.*]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT_T]], ptr [[BASE]], i64 0, i32 1, i64 [[IDX_1_EXT]], i64 [[IDX_2_EXT]]
; CHECK-NEXT:    [[T:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[T]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %idx.1, 2
  br i1 %cmp, label %then, label %else

then:
  %len.ext = zext i32 %len to i64
  %add.ptr = getelementptr inbounds %struct.T, ptr %base, i64 0, i32 1, i64 2, i64 %len.ext
  %idx.1.ext = zext i32 %idx.1 to i64
  %idx.2.ext = zext i32 %idx.2 to i64
  %gep = getelementptr %struct.T, ptr %base, i64 0, i32 1, i64 %idx.1.ext, i64 %idx.2.ext
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_upper_bound_2_var_size_gep_inbounds_1(ptr noundef %base, i32 %idx.1, i32 %idx.2, i32 %len.1, i32 %len.2) {
; CHECK-LABEL: @test_upper_bound_2_var_size_gep_inbounds_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_1_ULT:%.*]] = icmp ugt i32 [[LEN_1:%.*]], 2
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_ULT]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[LEN_2:%.*]], 2
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_1_EXT:%.*]] = zext i32 [[LEN_1]] to i64
; CHECK-NEXT:    [[LEN_2_EXT:%.*]] = zext i32 [[LEN_2]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_T:%.*]], ptr [[BASE:%.*]], i64 0, i32 1, i64 [[LEN_1_EXT]], i64 [[LEN_2_EXT]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT_T]], ptr [[BASE]], i64 0, i32 1, i64 1, i64 1
; CHECK-NEXT:    [[T:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[T]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %idx.1.ult = icmp ugt i32 %len.1, 2
  call void @llvm.assume(i1 %idx.1.ult)
  %cmp = icmp ugt i32 %len.2, 2
  br i1 %cmp, label %then, label %else

then:
  %len.1.ext = zext i32 %len.1 to i64
  %len.2.ext = zext i32 %len.2 to i64
  %add.ptr = getelementptr inbounds %struct.T, ptr %base, i64 0, i32 1, i64 %len.1.ext, i64 %len.2.ext
  %gep = getelementptr %struct.T, ptr %base, i64 0, i32 1, i64 1, i64 1
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define noundef i1 @test_upper_bound_2_var_size_gep_may_not_be_inbounds_2(ptr noundef %base, i32 %idx.1, i32 %idx.2, i32 %len.1, i32 %len.2) {
; CHECK-LABEL: @test_upper_bound_2_var_size_gep_may_not_be_inbounds_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[LEN_1:%.*]], 2
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_1_EXT:%.*]] = zext i32 [[LEN_1]] to i64
; CHECK-NEXT:    [[LEN_2_EXT:%.*]] = zext i32 [[LEN_2:%.*]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds [[STRUCT_T:%.*]], ptr [[BASE:%.*]], i64 0, i32 1, i64 [[LEN_1_EXT]], i64 [[LEN_2_EXT]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [[STRUCT_T]], ptr [[BASE]], i64 0, i32 1, i64 1, i64 1
; CHECK-NEXT:    [[T:%.*]] = icmp ult ptr [[GEP]], [[ADD_PTR]]
; CHECK-NEXT:    ret i1 [[T]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ugt i32 %len.1, 2
  br i1 %cmp, label %then, label %else

then:
  %len.1.ext = zext i32 %len.1 to i64
  %len.2.ext = zext i32 %len.2 to i64
  %add.ptr = getelementptr inbounds %struct.T, ptr %base, i64 0, i32 1, i64 %len.1.ext, i64 %len.2.ext
  %gep = getelementptr %struct.T, ptr %base, i64 0, i32 1, i64 1, i64 1
  %t = icmp ult ptr %gep, %add.ptr
  ret i1 %t

else:
  ret i1 0
}

define i32 @access_struct_1_checks_needed(ptr %src, i32 %size, i32 %idx) {
; CHECK-LABEL: @access_struct_1_checks_needed(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ult i32 [[IDX:%.*]], [[SIZE:%.*]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[CHECK:%.*]], label [[EXIT_2:%.*]]
; CHECK:       check:
; CHECK-NEXT:    [[SIZE_EXT:%.*]] = zext i32 [[SIZE]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds [[STRUCT_1:%.*]], ptr [[SRC:%.*]], i64 [[SIZE_EXT]]
; CHECK-NEXT:    [[ADD:%.*]] = add nuw i32 [[IDX]], 1
; CHECK-NEXT:    [[ADD_EXT:%.*]] = zext i32 [[ADD]] to i64
; CHECK-NEXT:    [[GEP_IDX_1:%.*]] = getelementptr [[STRUCT_1]], ptr [[SRC]], i64 [[ADD_EXT]]
; CHECK-NEXT:    [[GEP_NEXT:%.*]] = getelementptr [[STRUCT_1]], ptr [[GEP_IDX_1]], i64 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp ule ptr [[GEP_NEXT]], [[UPPER]]
; CHECK-NEXT:    br i1 [[C_1]], label [[CONT:%.*]], label [[EXIT_1:%.*]]
; CHECK:       cont:
; CHECK-NEXT:    [[C_2:%.*]] = icmp ult ptr [[GEP_IDX_1]], [[UPPER]]
; CHECK-NEXT:    br i1 [[C_2]], label [[EXIT_2]], label [[EXIT_1]]
; CHECK:       exit.1:
; CHECK-NEXT:    ret i32 1
; CHECK:       exit.2:
; CHECK-NEXT:    ret i32 3
;
entry:
  %cmp.not = icmp ult i32 %idx, %size
  br i1 %cmp.not, label %check, label %exit.2

check:
  %size.ext = zext i32 %size to i64
  %upper = getelementptr inbounds %struct.1, ptr %src, i64 %size.ext
  %add = add nuw i32 %idx, 1
  %add.ext = zext i32 %add to i64
  %gep.idx.1 = getelementptr %struct.1, ptr %src, i64 %add.ext
  %gep.next = getelementptr %struct.1, ptr %gep.idx.1, i64 1
  %c.1 = icmp ule ptr %gep.next, %upper
  br i1 %c.1, label %cont, label %exit.1

cont:
  %c.2 = icmp ult ptr %gep.idx.1, %upper
  br i1 %c.2, label %exit.2, label %exit.1

exit.1:
  ret i32 1

exit.2:
  ret i32 3
}
declare void @llvm.assume(i1)
