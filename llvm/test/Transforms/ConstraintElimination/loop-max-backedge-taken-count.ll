; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -p constraint-elimination -S %s | FileCheck %s

declare zeroext i8 @foo()

define i1 @test(ptr %arg) {
; CHECK-LABEL: define i1 @test(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[L:%.*]] = load i32, ptr [[ARG]], align 8
; CHECK-NEXT:    [[EC:%.*]] = icmp ugt i32 [[IV]], [[L]]
; CHECK-NEXT:    br i1 [[EC]], label [[EXIT:%.*]], label [[LOOP_LATCH]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    [[CALL:%.*]] = call zeroext i8 @foo()
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i8 [[CALL]], 2
; CHECK-NEXT:    br i1 [[C_1]], label [[RET_1:%.*]], label [[RET_2:%.*]]
; CHECK:       ret.1:
; CHECK-NEXT:    [[C_2:%.*]] = icmp eq i8 [[CALL]], 0
; CHECK-NEXT:    ret i1 [[C_2]]
; CHECK:       ret.2:
; CHECK-NEXT:    ret i1 false
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop.latch ]
  %l = load i32, ptr %arg, align 8
  %ec = icmp ugt i32 %iv, %l
  br i1 %ec, label %exit, label %loop.latch

loop.latch:
  %iv.next = add nuw nsw i32 %iv, 1
  br label %loop.header

exit:
  %call = call zeroext i8 @foo()
  %c.1 = icmp ult i8 %call, 2
  br i1 %c.1, label %ret.1, label %ret.2

ret.1:
  %c.2 = icmp eq i8 %call, 0
  ret i1 %c.2

ret.2:
  ret i1 false
}
