; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare void @use(i1 noundef)

define void @test_idx_known_positive(ptr noundef %buf, i32 noundef %len, i32 %idx) {
; CHECK-LABEL: @test_idx_known_positive(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_SLT_LEN:%.*]] = icmp slt i32 [[IDX:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    [[IDX_POS:%.*]] = icmp sge i32 [[IDX]], 0
; CHECK-NEXT:    [[PRECONDS:%.*]] = and i1 [[IDX_SLT_LEN]], [[IDX_POS]]
; CHECK-NEXT:    br i1 [[PRECONDS]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IDX_EXT]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 true, true
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    ret void
; CHECK:       else:
; CHECK-NEXT:    ret void
;
entry:
  %idx.slt.len = icmp slt i32 %idx, %len
  %idx.pos = icmp sge i32 %idx, 0
  %preconds = and i1 %idx.slt.len, %idx.pos
  br i1 %preconds, label %then , label %else

then:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %idx.ext = zext i32 %idx to i64
  %gep.idx = getelementptr i32, ptr %buf, i64 %idx.ext
  %t.1 = icmp ult ptr %gep.idx, %add.ptr
  %t.2 = icmp uge ptr %gep.idx, %buf
  %and = and i1 %t.1, %t.2
  call void @use(i1 %and)
  ret void

else:
  ret void
}

define void @test_idx_not_known_positive(ptr noundef %buf, i32 noundef %len, i32 %idx) {
; CHECK-LABEL: @test_idx_not_known_positive(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_SLT_LEN:%.*]] = icmp slt i32 [[IDX:%.*]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[IDX_SLT_LEN]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[IDX]] to i64
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IDX_EXT]]
; CHECK-NEXT:    [[T_1:%.*]] = icmp ult ptr [[GEP_IDX]], [[ADD_PTR]]
; CHECK-NEXT:    [[T_2:%.*]] = icmp uge ptr [[GEP_IDX]], [[BUF]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[T_1]], [[T_2]]
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    ret void
; CHECK:       else:
; CHECK-NEXT:    ret void
;
entry:
  %idx.slt.len = icmp slt i32 %idx, %len
  br i1 %idx.slt.len, label %then , label %else

then:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %idx.ext = zext i32 %idx to i64
  %gep.idx = getelementptr i32, ptr %buf, i64 %idx.ext
  %t.1 = icmp ult ptr %gep.idx, %add.ptr
  %t.2 = icmp uge ptr %gep.idx, %buf
  %and = and i1 %t.1, %t.2
  call void @use(i1 %and)
  ret void

else:
  ret void
}



define void @test_iv_known_positive(ptr noundef %buf, i32 noundef %len) {
; CHECK-LABEL: @test_iv_known_positive(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_LATCH]], label [[EXIT:%.*]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext i32 [[IV]] to i64
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IV_EXT]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 true, true
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]
  %cmp = icmp slt i32 %iv, %len
  br i1 %cmp, label %loop.latch, label %exit

loop.latch:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %iv.ext = zext i32 %iv to i64
  %gep.idx = getelementptr i32, ptr %buf, i64 %iv.ext
  %t.1 = icmp ult ptr %gep.idx, %add.ptr
  %t.2 = icmp uge ptr %gep.idx, %buf
  %and = and i1 %t.1, %t.2
  call void @use(i1 %and)
  %iv.next = add nuw nsw i32 %iv, 1
  br label %loop.header

exit:
  ret void
}

define void @test_iv_not_known_positive_1(ptr noundef %buf, i32 noundef %len) {
; CHECK-LABEL: @test_iv_not_known_positive_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ -3, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_LATCH]], label [[EXIT:%.*]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext i32 [[IV]] to i64
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IV_EXT]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[GEP_IDX]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[GEP_IDX]], [[BUF]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ -3, %entry ], [ %iv.next, %loop.latch ]
  %cmp = icmp slt i32 %iv, %len
  br i1 %cmp, label %loop.latch, label %exit

loop.latch:                                         ; preds = %loop.header
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %iv.ext = zext i32 %iv to i64
  %gep.idx = getelementptr i32, ptr %buf, i64 %iv.ext
  %c.1 = icmp ult ptr %gep.idx, %add.ptr
  %c.2 = icmp uge ptr %gep.idx, %buf
  %and = and i1 %c.1, %c.2
  call void @use(i1 %and)
  %iv.next = add nuw nsw i32 %iv, 1
  br label %loop.header

exit:
  ret void
}

define void @test_iv_not_known_positive_2(ptr noundef %buf, i32 noundef %len, i32 %start) {
; CHECK-LABEL: @test_iv_not_known_positive_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[START:%.*]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_LATCH]], label [[EXIT:%.*]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext i32 [[IV]] to i64
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IV_EXT]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[GEP_IDX]], [[ADD_PTR]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[GEP_IDX]], [[BUF]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ %start, %entry ], [ %iv.next, %loop.latch ]
  %cmp = icmp slt i32 %iv, %len
  br i1 %cmp, label %loop.latch, label %exit

loop.latch:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %iv.ext = zext i32 %iv to i64
  %gep.idx = getelementptr i32, ptr %buf, i64 %iv.ext
  %c.1 = icmp ult ptr %gep.idx, %add.ptr
  %c.2 = icmp uge ptr %gep.idx, %buf
  %and = and i1 %c.1, %c.2
  call void @use(i1 %and)
  %iv.next = add nuw nsw i32 %iv, 1
  br label %loop.header

exit:
  ret void
}

define void @test_multiple_variable_idx_known_positive_1(ptr noundef %buf, i32 noundef %len, i32 %idx.1, i32 %idx.2) {
; CHECK-LABEL: @test_multiple_variable_idx_known_positive_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_1_SLT_4:%.*]] = icmp slt i32 [[IDX_1:%.*]], 4
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_SLT_4]])
; CHECK-NEXT:    [[IDX_1_POS:%.*]] = icmp sge i32 [[IDX_1]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_POS]])
; CHECK-NEXT:    [[IDX_2_SLT_3:%.*]] = icmp slt i32 [[IDX_2:%.*]], 3
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_2_SLT_3]])
; CHECK-NEXT:    [[IDX_2_POS:%.*]] = icmp sge i32 [[IDX_2]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_2_POS]])
; CHECK-NEXT:    [[LEN_POS:%.*]] = icmp sge i32 [[LEN:%.*]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[LEN_POS]])
; CHECK-NEXT:    [[C_SLT_LEN:%.*]] = icmp slt i32 8, [[LEN]]
; CHECK-NEXT:    br i1 [[C_SLT_LEN]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_1_EXT:%.*]] = sext i32 [[IDX_1]] to i64
; CHECK-NEXT:    [[GEP_IDX_1:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IDX_1_EXT]]
; CHECK-NEXT:    [[IDX_2_EXT:%.*]] = sext i32 [[IDX_2]] to i64
; CHECK-NEXT:    [[GEP_IDX_2:%.*]] = getelementptr i32, ptr [[GEP_IDX_1]], i64 [[IDX_2_EXT]]
; CHECK-NEXT:    [[T_1:%.*]] = icmp ult ptr [[GEP_IDX_2]], [[ADD_PTR]]
; CHECK-NEXT:    [[T_2:%.*]] = icmp uge ptr [[GEP_IDX_2]], [[BUF]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[T_1]], [[T_2]]
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    ret void
; CHECK:       else:
; CHECK-NEXT:    ret void
;
entry:
  %idx.1.slt.4 = icmp slt i32 %idx.1, 4
  call void @llvm.assume(i1 %idx.1.slt.4)
  %idx.1.pos = icmp sge i32 %idx.1, 0
  call void @llvm.assume(i1 %idx.1.pos)
  %idx.2.slt.3 = icmp slt i32 %idx.2, 3
  call void @llvm.assume(i1 %idx.2.slt.3)
  %idx.2.pos = icmp sge i32 %idx.2, 0
  call void @llvm.assume(i1 %idx.2.pos)
  %len.pos = icmp sge i32 %len, 0
  call void @llvm.assume(i1 %len.pos)
  %c.slt.len = icmp slt i32 8, %len
  br i1 %c.slt.len, label %then , label %else

then:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %idx.1.ext = sext i32 %idx.1 to i64
  %gep.idx.1 = getelementptr i32, ptr %buf, i64 %idx.1.ext
  %idx.2.ext = sext i32 %idx.2 to i64
  %gep.idx.2 = getelementptr i32, ptr %gep.idx.1, i64 %idx.2.ext
  %t.1 = icmp ult ptr %gep.idx.2, %add.ptr
  %t.2 = icmp uge ptr %gep.idx.2, %buf
  %and = and i1 %t.1, %t.2
  call void @use(i1 %and)
  ret void

else:
  ret void
}

define void @test_multiple_variable_idx_known_positive_2(ptr noundef %buf, i32 noundef %len, i32 %idx.1, i32 %idx.2) {
; CHECK-LABEL: @test_multiple_variable_idx_known_positive_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_1_SLT_4:%.*]] = icmp slt i32 [[IDX_1:%.*]], 4
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_SLT_4]])
; CHECK-NEXT:    [[IDX_1_POS:%.*]] = icmp sge i32 [[IDX_1]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_1_POS]])
; CHECK-NEXT:    [[IDX_2_SLT_3:%.*]] = icmp slt i32 [[IDX_2:%.*]], 3
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_2_SLT_3]])
; CHECK-NEXT:    [[IDX_2_POS:%.*]] = icmp sge i32 [[IDX_2]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[IDX_2_POS]])
; CHECK-NEXT:    [[LEN_POS:%.*]] = icmp sge i32 [[LEN:%.*]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[LEN_POS]])
; CHECK-NEXT:    [[C_SLT_LEN:%.*]] = icmp slt i32 4, [[LEN]]
; CHECK-NEXT:    br i1 [[C_SLT_LEN]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[LEN_EXT:%.*]] = sext i32 [[LEN]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[BUF:%.*]], i64 [[LEN_EXT]]
; CHECK-NEXT:    [[IDX_1_EXT:%.*]] = sext i32 [[IDX_1]] to i64
; CHECK-NEXT:    [[GEP_IDX_1:%.*]] = getelementptr i32, ptr [[BUF]], i64 [[IDX_1_EXT]]
; CHECK-NEXT:    [[IDX_2_EXT:%.*]] = sext i32 [[IDX_2]] to i64
; CHECK-NEXT:    [[GEP_IDX_2:%.*]] = getelementptr i32, ptr [[GEP_IDX_1]], i64 [[IDX_2_EXT]]
; CHECK-NEXT:    [[T_1:%.*]] = icmp ult ptr [[GEP_IDX_2]], [[ADD_PTR]]
; CHECK-NEXT:    [[T_2:%.*]] = icmp uge ptr [[GEP_IDX_2]], [[BUF]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[T_1]], [[T_2]]
; CHECK-NEXT:    call void @use(i1 [[AND]])
; CHECK-NEXT:    ret void
; CHECK:       else:
; CHECK-NEXT:    ret void
;
entry:
  %idx.1.slt.4 = icmp slt i32 %idx.1, 4
  call void @llvm.assume(i1 %idx.1.slt.4)
  %idx.1.pos = icmp sge i32 %idx.1, 0
  call void @llvm.assume(i1 %idx.1.pos)
  %idx.2.slt.3 = icmp slt i32 %idx.2, 3
  call void @llvm.assume(i1 %idx.2.slt.3)
  %idx.2.pos = icmp sge i32 %idx.2, 0
  call void @llvm.assume(i1 %idx.2.pos)
  %len.pos = icmp sge i32 %len, 0
  call void @llvm.assume(i1 %len.pos)
  %c.slt.len = icmp slt i32 4, %len
  br i1 %c.slt.len, label %then , label %else

then:
  %len.ext = sext i32 %len to i64
  %add.ptr = getelementptr inbounds i32, ptr %buf, i64 %len.ext
  %idx.1.ext = sext i32 %idx.1 to i64
  %gep.idx.1 = getelementptr i32, ptr %buf, i64 %idx.1.ext
  %idx.2.ext = sext i32 %idx.2 to i64
  %gep.idx.2 = getelementptr i32, ptr %gep.idx.1, i64 %idx.2.ext
  %t.1 = icmp ult ptr %gep.idx.2, %add.ptr
  %t.2 = icmp uge ptr %gep.idx.2, %buf
  %and = and i1 %t.1, %t.2
  call void @use(i1 %and)
  ret void

else:
  ret void
}

declare void @llvm.assume(i1)
