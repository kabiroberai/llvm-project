; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals --version 2
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s
; REQUIRES: apple-disclosure-ios

; Changed check lines for annotation to ensure annotations are attatched to the correct instruction.

declare void @use(i1)
define void @loop_gep_phi(ptr %a, i32 %n) {
; CHECK-LABEL: define void @loop_gep_phi
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[N_1:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[N_1]], [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    br i1 true, label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]], !annotation !0
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[INC]] = sub nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %n_1 = sub i32 %n , 1
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ %n_1, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp uge i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 1
  %inc = sub nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @loop_gep_phi_step_size(ptr %a, i32 %n) {
; CHECK-LABEL: define void @loop_gep_phi_step_size
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MUL:%.*]] = shl nsw i32 [[N]], 1, !annotation !3
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[MUL]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[IDX_EXT]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[A]], [[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]], !annotation !5
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[PTR_IV]], [[A]], !annotation !7
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i32, ptr [[PTR_IV]], i64 2
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %mul = shl nsw i32 %n, 1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %idx.ext
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %ptr.iv = phi ptr [ %a, %entry ], [ %ptr.iv.next, %for.body ]
  %cmp = icmp uge i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %ptr.iv.next = getelementptr inbounds i32, ptr %ptr.iv, i64 2
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

!0 = !{!"bounds-safety-check-ptr-lt-upper-bound"}
!1 = !{!"bounds-safety-check-ptr-ge-lower-bound"}
;.
; CHECK: [[META0:![0-9]+]] = !{!"bounds-safety-check-ptr-lt-upper-bound", !1}
; CHECK: [[META1:![0-9]+]] = !{!"bounds-safety-missed-optimization-phi-direction", !"Cannot remove bounds checks because the pointer induction variable and loop counter are not stepping in the same direction. Consider rewriting the loop counter to step in the same direction as the pointer induction variable to help the optimizer remove the access bound checks."}
; CHECK: [[META2:![0-9]+]] = !{!"bounds-safety-check-ptr-ge-lower-bound", !1}
; CHECK: [[META3:![0-9]+]] = !{!4}
; CHECK: [[META4:![0-9]+]] = !{!"bounds-safety-missed-optimization-nuw", !"Check can not be removed because the arithmetic operation might wrap in the unsigned sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
; CHECK: [[META5:![0-9]+]] = !{!"bounds-safety-check-ptr-lt-upper-bound", !6}
; CHECK: [[META6:![0-9]+]] = !{!"bounds-safety-missed-optimization-phi-step-size", !"Cannot remove bound checks because the pointer induction variable and loop counter don't have the same step size. Consider rewriting the loop counter to have the same step size as the pointer induction variable to help the optimizer remove the access bound checks"}
; CHECK: [[META7:![0-9]+]] = !{!"bounds-safety-check-ptr-ge-lower-bound", !6}
;.
