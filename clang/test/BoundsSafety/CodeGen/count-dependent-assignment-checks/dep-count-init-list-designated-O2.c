// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py

// RUN: %clang_cc1 -O2  -fbounds-safety -emit-llvm -triple x86_64 %s -o - | FileCheck %s
#include <ptrcheck.h>

struct S {
    int len;
    int *__counted_by(len) ptr;
};

// CHECK-LABEL: @TestFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], !annotation !{{[0-9]+}}
// CHECK-NEXT:    unreachable
//
void TestFail() {
  int arr[10];
  int len = 11;
  struct S s = {.ptr = arr, .len = len};
}

// CHECK-LABEL: @TestOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestOK() {
  int len = 0;
  struct S s = {.len = len};
}

struct S2 {
  int len;
  int *__counted_by(len+1) ptr;
};

// CHECK-LABEL: @Test2OK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void Test2OK() {
  int len = -1;
  struct S2 s = {.len = len, .ptr = 0};
}

// CHECK-LABEL: @Test2Fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], !annotation !{{[0-9]+}}
// CHECK-NEXT:    unreachable
//
void Test2Fail() {
  int len = 0;
  struct S2 s = {.len = len, .ptr = 0};
}

struct S3 {
  int *__counted_by(len+2) ptr;
  int len;
};


// CHECK-LABEL: @Test3OK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void Test3OK() {
  int a[2];
  struct S3 s = {.len = 0, .ptr = a};
}

// CHECK-LABEL: @Test3Fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], !annotation !{{[0-9]+}}
// CHECK-NEXT:    unreachable
//
void Test3Fail() {
  int a;
  struct S3 s = {.len = 0, .ptr = &a}; // trap
}
